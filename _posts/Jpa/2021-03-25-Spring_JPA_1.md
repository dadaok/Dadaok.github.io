---
layout:   post
title:    "Spring"
subtitle: "Spring"
category: Jpa
more_posts: posts.md
tags:     Jpa
---
# [JPA 활용] 1. Spring

<!--more-->
<!-- Table of contents -->
* this unordered seed list will be replaced by the toc
{:toc}

<!-- text -->

## 계층별 참고 및 주의 사항

### Controller
- 엔티티를 RequestBody로 직접 맵핑하지 말자
  - 로직이 들어갈 수 있으며, 오염 될 수 있다.
  - 그런 모든 요청 요구사항을 담기는 어렵다.
  - 엔티티가 변경되면 API 스펙이 변한다.
- 엔티티를 응답 값으로 노출하지 말자.
  - 엔티티의 모든 값이 노출되면 위험하다.
  - 스펙을 맞추기 위한 로직이 추가 될 수 있다.
  - 엔티티가 변경되면 API 스펙이 변한다.

### Entity
- id는 편의를 위해 id로 명시 후 name을 따로 써주자
- 엔티티는 핵심 비즈니스 로직만 가지고 있고, 화면을 위한 로직은 없어야 한다.
- 화면이나 API에 맞는 폼 객체나 DTO를 사용하자. 그래서 화면이나 API 요구사항을 이것들로 처리하고, 엔티티는 최대한 순수하게 유지 하자.

``` java
    @Id @GeneratedValue
    @Column(name = "order_id") 
    private Long id;
```

### Repository
- @Repository : 스프링 빈으로 등록, JPA 예외를 스프링 기반 예외로 예외 변환 
- @PersistenceContext : 엔티티 메니저( EntityManager ) 주입
- @PersistenceUnit : 엔티티 메니터 팩토리( EntityManagerFactory ) 주입(@PersistenceContext 를 통해 EntityManager 를 주입 받아 사용할 수 있기 때문에 잘 사용하지 않는다)


### Service
- @Transactional : 트랜잭션, 영속성 컨텍스트
  - readOnly=true : 데이터의 변경이 없는 읽기 전용 메서드에 사용, 영속성 컨텍스트를 플러시 하지 않으므로 약간의 성능 향상(읽기 전용에는 다 적용)
  - 데이터베이스 드라이버가 지원하면 DB에서 성능 향상(특정 데이터베이스 드라이버나 데이터베이스 관리 시스템(DBMS)이 읽기 전용 트랜잭션을 인식하고 특별한 최적화)
- @Autowired대신 생성자 주입 방식 권장
  - final 키워드를 필드에 추가하면, 그 필드는 반드시 생성자에서 초기화되어야 하기때문에 필수적인 의존성이 누락되는 실수를 방지할 수 있다.
  - 변경 불가능한 안전한 객체 생성 가능
  - 순환 참조 방지 : 순환 참조가 있는 경우 애플리케이션 구동 시점에 바로 에러가 발생(final로 선언된 변수는 반드시 선언시, 혹은 객체가 생성될 때 생성자 내에서 초기화되어야 합니다. 이는 컴파일 시점에 체크되는 조건)

### Test
- @Transactional를 붙일 경우 반복 가능한 테스트 지원, 각각의 테스트를 실행할 때마다 트랜잭션을 시작하고 테스트가 끝나면 트랜잭션을 강제로 롤백

## 변경 감지와 병합
>  병합(merge)은 준영속 상태의 엔티티를 수정할 때 사용한다. 영속 상태의 엔티티는 변경 감지(dirty checking)기능이 동작해서 트랜잭션을 커밋할 때 자동으로 수정되므로 별도의 수정 메서드를 호출할 필요가 없고 그런 메서드도 없다. 

### 준영속 엔티티?
> 영속성 컨텍스트가 더는 관리하지 않는 엔티티를 말한다.  
(ex : itemService.saveItem(book) 에서 수정을 시도하는 Book 객체다. Book 객체는 이미 DB에 한번 저장되어서 식별자가 존재한다. 이렇게 임의로 만들어낸 엔티티도 기존 식별자를 가지고 있으면 준영속 엔티티로 볼 수 있다)

### 변경 감지
> 영속성 컨텍스트에서 엔티티를 다시 조회한 후에 데이터를 수정하는 방법  
트랜잭션 안에서 엔티티를 다시 조회, 변경할 값 선택 트랜잭션 커밋 시점에 변경 감지(Dirty Checking)이 동작해서 데이터베이스에 UPDATE SQL 실행

``` java
@Transactional
void update(Item itemParam) { //itemParam: 파리미터로 넘어온 준영속 상태의 엔티티
Item findItem = em.find(Item.class, itemParam.getId()); //같은 엔티티를 조회한다. 
    findItem.setPrice(itemParam.getPrice()); //데이터를 수정한다.
}
```
### 병합 사용
> 병합은 준영속 상태의 엔티티를 영속 상태로 변경할 때 사용하는 기능이다. (merge)

``` java
@Transactional
void update(Item itemParam) { //itemParam: 파리미터로 넘어온 준영속 상태의 엔티티 
    Item mergeItem = em.merge(itemParam);
}
```

1. merge() 를 실행한다.
2. 파라미터로 넘어온 준영속 엔티티의 식별자 값으로 1차 캐시에서 엔티티를 조회한다.
   1. 만약 1차 캐시에 엔티티가 없으면 데이터베이스에서 엔티티를 조회하고, 1차 캐시에 저장한다.
3. 조회한 영속 엔티티( mergeMember )에 member 엔티티의 값을 채워 넣는다. (member 엔티티의 모든 값을 mergeMember에 밀어 넣는다. 이때 mergeMember의 “회원1”이라는 이름이 “회원명변경”으로 바뀐다.)
4. 영속 상태인 mergeMember를 반환한다.

#### 병합시 동작 방식을 간단히 정리
1. 준영속 엔티티의 식별자 값으로 영속 엔티티를 조회한다.
2. 영속 엔티티의 값을 준영속 엔티티의 값으로 모두 교체한다.(병합한다.)
3. 트랜잭션 커밋 시점에 변경 감지 기능이 동작해서 데이터베이스에 UPDATE SQL이 실행

##### 주의
> 변경 감지 기능을 사용하면 원하는 속성만 선택해서 변경할 수 있지만, 병합을 사용하면 모든 속성이 변경된다. 병합시 값이 없으면 null 로 업데이트 할 위험도 있다. (병합은 모든 필드를 교체한다.)

``` java
@Repository
public class ItemRepository {

    @PersistenceContext
    EntityManager em;

    public void save(Item item) { 
    if (item.getId() == null) {
            em.persist(item); 
        } else { 
            em.merge(item); 
        }
    }
    //...
}
```

##### 추천 팁!
> 엔티티를 변경할 때는 항상 변경 감지를 사용하자!

- 컨트롤러에서 어설프게 엔티티를 생성하지 말자
- 트랜잭션이 있는 서비스 계층에 식별자( id )와 변경할 데이터를 명확하게 전달하자.(파라미터 or dto) 
- 트랜잭션이 있는 서비스 계층에서 영속 상태의 엔티티를 조회하고, 엔티티의 데이터를 직접 변경! 
- 트랜잭션 커밋 시점에 변경 감지가 실행

``` java
@Entity
public class Item {
    // 기존 필드 정의 생략

    // 비즈니스 로직 메소드 추가
    public void updateInfo(String name, int price, int stockQuantity) {
        this.name = name;
        this.price = price;
        this.stockQuantity = stockQuantity;
    }
}

@Service
@RequiredArgsConstructor 
public class ItemService {
    private final ItemRepository itemRepository; 

    @Transactional
    public void updateItem(Long id, String name, int price, int stockQuantity) { 
        Item item = itemRepository.findOne(id);
        item.updateInfo(name, price, stockQuantity);
    }
}
```