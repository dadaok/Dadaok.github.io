---
layout:   post
title:    "Mapping"
subtitle: "Mapping"
category: Jpa
more_posts: posts.md
tags:     Jpa
---
# Mapping

<!--more-->
<!-- Table of contents -->
* this unordered seed list will be replaced by the toc
{:toc}

<!-- text -->

## 엔티티 매핑 소개
- 객체와 테이블 매핑: @Entity, @Table
- 필드와 컬럼 매핑: @Column
- 기본 키 매핑: @Id
- 연관관계 매핑: @ManyToOne, @JoinColumn 

## @Entity
- @Entity가 붙은 클래스는 JPA가 관리, 엔티티라 한다.
- JPA를 사용해서 테이블과 매핑할 클래스는 @Entity 필수

## @Table
> Java 엔티티와 DB 테이블의 네이밍 차이 해결을 위해 name 속성을 주로 사용. 나머지는 많이 사용하지 않는 듯하다.

- name : 매핑할 테이블 이름
- catalog : 데이터베이스 catalog 매핑
- schema : 데이터베이스 schema 매핑
- uniqueConstraints(DDL) : DDL 생성 시에 유니크 제약 조건 생성

### 주의
- 기본 생성자 필수(파라미터가 없는 public 또는 protected 생성자)
- ﬁnal 클래스, enum, interface, inner 클래스 사용X
- 저장할 필드에 ﬁnal 사용 X
- hibernate.hbm2ddl.auto : DDL 자동 생성은 되도록 사용 지양(기본 none 사용 권장)

## Entity 내에 사용되는 어노테이션

``` java
@Entity
public class Member {
    @Id
    private Long id;
    @Column(name = "name") 
    private String username;
    private Integer age;
    @Enumerated(EnumType.STRING) // 주의! 기본값인 EnumType.ORDINAL 사용X(순서가 바뀔경우 망함)
    private RoleType roleType;
    @Temporal(TemporalType.TIMESTAMP) // 옵션으로 DATE, TIME, TIMESTAMP 가 있음
    private Date createdDate;
    @Temporal(TemporalType.TIMESTAMP) 
    private Date lastModifiedDate;
    @Lob
    private String description; 
    @Transient
    private String tmpValues; // DB연관X, 임시로 어떤 값을 보관하고 싶을 때 사용
    //Getter, Setter…
}
```

### 기본키
- 직접 할당: @Id만 사용
- 자동 생성(@GeneratedValue)
  - IDENTITY: 데이터베이스에 위임(MySQL과 SQL Server 에서 주로 사용 AUTO_ INCREMENT)
  - SEQUENCE: 데이터베이스 시퀀스 오브젝트 사용( Oracle, PostgreSQL, H2 에서 주로 사용)
    - @SequenceGenerator 필요
  - TABLE: 키 생성용 테이블 사용, 모든 DB에서 사용(다른 전략을 사용할 수 없는 경우 마지막 수단으로 사용)
    - @TableGenerator 필요
  - AUTO: 방언에 따라 자동 지정, 기본값

``` java
// IDENTITY 전략 - 매핑
@Entity
public class Member {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY) 
    private Long id;

// SEQUENCE 전략 - 특징
@Entity
@SequenceGenerator(
    name = “MEMBER_SEQ_GENERATOR",
    sequenceName = “MEMBER_SEQ", //매핑할 데이터베이스 시퀀스 이름 
    initialValue = 1, allocationSize = 1)
public class Member {
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "MEMBER_SEQ_GENERATOR") 
    private Long id;

// TABLE 전략 - 매핑(단점 성능..)
// create table MY_SEQUENCES (
//  sequence_name varchar(255) not null, 
//  next_val bigint,
//  primary key ( sequence_name ) 
// )
@Entity
@TableGenerator(
    name = "MEMBER_SEQ_GENERATOR", 
    table = "MY_SEQUENCES",
    pkColumnValue = "MEMBER_SEQ", allocationSize = 1) 
public class Member {
    @Id
    @GeneratedValue(strategy = GenerationType.TABLE, generator = "MEMBER_SEQ_GENERATOR")
    private Long id;

```

### 권장하는 식별자 전략
- 기본 키 제약 조건: null 아님, 유일, 변하면 안된다.
- 미래까지 이 조건을 만족하는 자연키는 찾기 어렵다. 대리키(대체키)를 사용하자.
- 예를 들어 주민등록번호도 기본 키로 적절하기 않다.
- 권장: Long형 + 대체키 + 키 생성전략 사용

## Entity간 연관관계 맵핑
> JPA는 @ManyToOne, @OneToMany, @OneToOne, @ManyToMany 어노테이션으로 연관 관계를 매핑하고, 연관 관계의 주인이 외래 키를 관리한다.(등록, 수정)  
> 연관 관계의 주인은 주로 'Many' 쪽에 설정하며, 다음과 같이 사용한다.(또는 외래 키가 있는 있는 곳)  

``` java
    @ManyToOne
    @JoinColumn(name = "TEAM_ID") 
    private Team team;
```
> 사용 여부에 따라 반대편도 아래와 같이 설정할 수 있다. (확실하지 않을 경우 일반적으로 미리 설정해 둔다)  

``` java
    @OneToMany(mappedBy = "team")
    List<Member> members = new ArrayList<Member>();
```

### 주의
> 양방향 매핑시 연관관계의 주인에 값을 입력해야 한다.(실수 많이 함)

``` java
    Team team = new Team(); 
    team.setName("TeamA"); 
    em.persist(team);

    Member member = new Member(); 
    member.setName("member1");

    team.getMembers().add(member); 
    //연관관계의 주인에 값 설정
    member.setTeam(team); //** 

    em.persist(member);
```