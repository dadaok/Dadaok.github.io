---
layout:   post
title:    "변수!!"
subtitle: "Variable"
category: Java
more_posts: posts.md
tags:     Java
---
# 변수

<!--more-->
<!-- Table of contents -->
* this unordered seed list will be replaced by the toc
{:toc}

<!-- text -->

## 변수의 타입
자료형은 크게 "기본형"과 "참조형" 두 가지로 나뉜다.  
기본형은 실제 값(data)를 저장하고, 참조형은 값이 저장되어있는 메모리 공간의 주소(address)를 값으로 갖는다.  

> 기본형(primitive type)  
- 논리형(boolean), 문자형(char), 정수형(byte, short, int, long), 실수형(float, double), 참조형(reference type)  
- 8개의 기본형을 제외한 나머지 타입, 객체의 주소를 저장

### 참조형(reference type) 변수
기본형 8가지를 제외한 나머지 타입  
참조형 변수를 선언할 때는 변수의 타입으로 클래스의 이름을 사용하므로 클래스의 이름이 참조형 변수의 타입이 됩니다. 따라서 새로운 클래스를 작성하는 것은 새로운 참조형 변수를 추가한다고 봐도 무방합니다.  

``` java
Date today = new Date();
```
Date 클래스 타입의 참조형 변수 today를 선언한 것입니다.  
참조형 변수는 null 또는 주소를 값으로 갖습니다.  
연산자 new의 결과는 생성된 객체의 주소이다. 이 주소가 대입연산자 =에 의해서 참조형 변수 today에 저장되는 것입니다.  

### 상수와 리터럴(constatns & literal)
"상수"는 변수와 마찬가지로 값을 저장할 수 있는 공간이지만, 변수와 달리 값을 한 번 저장하면 변경할 수 없다.  

``` java
// 상수 선언 시 변수타입 앞에 "final"을 붙여주면 된다
final int MAX_SPEED = 10;
```

상수는 반드시 선언과 동시에 초기화를 하는것을 권장하고, 그 후에는 값을 변경할 수 없다.  

### 형 변환(캐스팅, casting)
형 변환은 변수 또는 상수(리터럴)의 타입을 다른 타입으로 변환하는 것이다.  
서로 타입이 다른 값끼리 연산을 해야할 때 타입을 일치시킨 후 연산을 해야하므로 형 변환이 필요하다.  
형 변환의 방법은 아주 간단한데, 형 변환하고자 하는 변수나 리터럴 앞에 타입을 괄호와 함께 붙여주면 된다.  

``` java
// 형 변환 방법 : 타입(피연산자)
double d = 85.4;
int score = (int)d;		// double타입의 변수 d를 int타입으로 변환
```

위 예제에서 변수 d 자체가 int형으로 형 변환된게 아니라, d의 값을 읽어 형 변환 후 그 결과를 반환하여 대입할 뿐이다.  
즉 변수 d의 값은 형변환 후에도 아무런 변화가 없다.  

기본형에서 boolean을 제외한 모든 타입들은 서로 형 변환이 가능하다.  
큰 타입에서 작은 타입으로 변환할 때는 타입의 크기가 작아지기 때문에 크기의 차이만큼 값이 잘려나간다.  
그래서 경우에 따라 값 손실이 발생할 수 있으니 고려해야한다.  
  
### 자동 형 변환
서로 다은 타입간의 대입이나 연산을 할 때, 형 변환으로 타입을 일치시키는 것이 원칙이다.  
하지만, 경우에 따라 편의성을 위해 형 변환을 생략할 수 있다.  
형 변환을 생략 시 형 변환이 이루어지지 않는 것은 아니고, 컴파일러가 자동적으로 추가한다.  
  
범위가 큰 타입에 작은 타입을 저장하려 하는 경우 자동 형 변환이 이루어진다.  
반대로 범위가 작은 타입에 큰 타입을 저장하려하면 에러가 발생하는데, 이는 값의 손실이 날 수 있기 때문이다.  

``` java
double d = 1234;	// 에러 X, double d = (float)1234; 와 동일
byte b = 1000;		// 에러 O, 1000은 byte 범위(-128~127)을 넘어감
```

위 byte 예시의 에러를 해결하려면 처음 배운 명시적 형 변환​으로 선언하면 해결할 수 있다.  
명시적 형 변환은 프로그래머가 의도적으로 변환 한 것이기 때문에 값 손실이 있더라도 에러를 발생시키지 않는다.  
  
연산 시에도 자동 형 변환이 이루어지는데, 연산되는 두 타입 중 더 넓은(큰) 타입으로 형 변환하여 타입을 일치시킨 후 연산한다.  
이는 값 손실의 위험이 더 적기 때문에 올바른 결과를 얻을 확률이 높다.  

``` java
int a = 10;
double b = 1.1 + a;		// 형변환을 하지 않아도 더 큰 타입인 double형으로 연산되어 반환
```

### 자동 형 변환의 규칙

- 기존의 값을 최대한 보존할 수 있는 타입으로 자동 형 변환한다.
- boolean을 제외한 나머지 7개의 기본형은 서로 형 변환이 가능하다.
- 기본형과 참조형은 서로 형 변환할 수 없다.
- 서로 다른 타입의 변수간에 연산은 형 변환을 하는 것이 원칙이지만, 값의 범위가 작은 타입에서 큰 타입으로의 형 변환은 생략할 수 있다.